= Certificates

During the installation of {productname}, a CA (Certificate Authority) certificate is generated,
which is then used to authenticate and verify all communication. This process also creates
and distributes client and server certificates for the components.

== Communication Security
Communication is secured with TLS v1.2 using the AES 128 CBC cipher.
All certificates are 2048 bit RSA encrypted.

== Certificate Validity
The CA certificate is valid for 3650 days (10 years) by default.
Client and server certificates are valid for 365 days (1 year) by default.

== Certificate Location
Required CAs for {productname} are stored on all master nodes:

[%header,cols=3*]
|===
|Common Name
|Path
|Description

|kubernetes
|/etc/kubernetes/pki/ca.crt,key
|kubernetes general CA

|etcd-ca
|/etc/kubernetes/pki/etcd/ca.crt,key
|Etcd cluster

|kubelet-ca
|/var/lib/kubelet/pki/kubelet-ca.crt,key
|Kubelet components

|front-proxy-ca
|/etc/kubernetes/pki/front-proxy-ca.crt,key
|Front-proxy components
|===

The following certificates are managed by `kubeadm`:

[%header,cols=4*]
|===
|Common Name
|Parent CA
|Path (`/etc/kubernetes/pki`)
|Kind

|kubernetes
|
|ca.crt,key
|CA

|kube-apiserver
|kubernetes
|apiserver.crt,key
|Server

|kube-apiserver-etcd-client
|etcd-ca
|apiserver-etcd-client.crt,key
|Client

|kube-apiserver-kubelet-client
|kubernetes
|apiserver-kubelet-client.crt,key
|Client

|etcd-ca
|
|etcd/ca.crt,key
|CA

|kube-etcd-healthcheck-client
|etcd-ca
|etcd/healthcheck-client.crt,key
|Client

|kube-etcd-peer
|etcd-ca
|etcd/peer.crt,key
|Server,Client

|kube-etcd-server
|etcd-ca
|etcd/server.crt,key
|Server,Client

|front-proxy-ca
|
|front-proxy-ca.crt,key
|CA

|front-proxy-client
|front-proxy-ca
|front-proxy-client.crt,key
|Client
|===

The following certificates are created by `skuba`:

* stored in the {kube} cluster as file format:
+
[%header,cols=4*]
|===
|Common Name
|Parent CA
|Path (`/var/lib/kubelet/pki`)
|Kind

|kubelet-ca
|
|kubelet-ca.crt,key
|CA
|===

* stored in the {kube} cluster as `Secret` resource:
+
[%header,cols=4*]
|===
|Common Name
|Parent CA
|Secret Resource Name
|Kind

|oidc-dex
|kubernetes
|oidc-dex-cert
|Server

|oidc-gangway
|kubernetes
|oidc-gangway-cert
|Server

|metrics-server
|kubernetes
|metrics-server-cert
|Server

|cilium-etcd-client
|etcd-ca
|cilium-secret
|Client
|===

== Monitoring Certificates

We use cert-exporter to monitor nodes' on-host certificates and addons' secret certificates. The cert-exporter collects the metrics of certificates expiration periodically (1 hour by default) and exposes them through the `/metrics` endpoint. Then, the Prometheus server can scrape these metrics from the endpoint periodically.

[source,bash]
----
helm repo add suse https://kubernetes-charts.suse.com
helm install suse/cert-exporter --name ${RELEASE_NAME}
----

=== Prerequisites

. To monitor certificates, we need to set up monitoring stack by following the <<monitoring-stack>> on how to deploy it.
. Label the skuba addon certificates
+
[source,bash]
----
kubectl label --overwrite secret oidc-dex-cert -n kube-system caasp.suse.com/skuba-addon=true
kubectl label --overwrite secret oidc-gangway-cert -n kube-system caasp.suse.com/skuba-addon=true
kubectl label --overwrite secret metrics-server-cert -n kube-system caasp.suse.com/skuba-addon=true
----
+
[NOTE]
====
You might see the following console output:
[source,bash]
----
secret/oidc-dex-cert not labeled
secret/oidc-gangway-cert not labeled
secret/metrics-server-cert not labeled
----
This is because `skuba` has already added the labels for you.
====

=== Prometheus Alerts

Use Prometheus alerts to reactively receive the status of the certificates, follow the <<alertmanager-configuration-example>> on how to configure the Prometheus Alertmanager and Prometheus Server.

=== Grafana Dashboards

Use Grafana to proactively monitor the status of the certificates, follow the <<adding-grafana-dashboards>> to install the Grafana dashboard to monitors certificates.

=== Monitor Custom Secret Certificates

You can monitor custom secret TLS certificates that you created manually or using link:https://cert-manager.io/[cert-manager].

For example:

. Monitor cert-manager issued certificates in the `cert-managert-test` namespace.
+
[source,bash]
----
helm install suse/cert-exporter \
    --name ${RELEASE_NAME} \
    --set customSecret.enabled=true \
    --set customSecret.certs[0].name=cert-manager \
    --set customSecret.certs[0].namespace=cert-manager-test \
    --set customSecret.certs[0].includeKeys="{ca.crt,tls.crt}" \
    --set customSecret.certs[0].annotationSelector="{cert-manager.io/certificate-name}"
----
. Monitor certificates in all namespaces filtered by label selector.
+
[source,bash]
----
helm install suse/cert-exporter \
    --name ${RELEASE_NAME} \
    --set customSecret.enabled=true \
    --set customSecret.certs[0].name=self-signed-cert \
    --set customSecret.certs[0].includeKeys="{ca.crt,tls.crt}" \
    --set customSecret.certs[0].labelSelector="{key=value}"
----
. Deploy both 1. and 2. together.
+
[source,bash]
----
helm install suse/cert-exporter \
    --name ${RELEASE_NAME} \
    --set customSecret.enabled=true \
    --set customSecret.certs[0].name=cert-manager \
    --set customSecret.certs[0].namespace=cert-manager-test \
    --set customSecret.certs[0].includeKeys="{ca.crt,tls.crt}" \
    --set customSecret.certs[0].annotationSelector="{cert-manager.io/certificate-name}" \
    --set customSecret.certs[1].name=self-signed-cert \
    --set customSecret.certs[1].includeKeys="{ca.crt,tls.crt}" \
    --set customSecret.certs[1].labelSelector="{key=value}"
----
. Monitor custom certificates only, disregarding node and addon certificates.
+
[source,bash]
----
helm install suse/cert-exporter \
    --name ${RELEASE_NAME} \
    --set node.enabled=false \
    --set addon.enabled=false \
    --set customSecret.enabled=true \
    --set customSecret.certs[0].name=cert-manager \
    --set customSecret.certs[0].namespace=cert-manager-test \
    --set customSecret.certs[0].includeKeys="{ca.crt,tls.crt}" \
    --set customSecret.certs[0].annotationSelector="{cert-manager.io/certificate-name}" \
    --set customSecret.certs[1].name=self-signed-cert \
    --set customSecret.certs[1].includeKeys="{ca.crt,tls.crt}" \
    --set customSecret.certs[1].labelSelector="{key=value}"
----

== Using Custom Trusted CA Certificates

=== During Cluster Deployment

[WARNING]
====
Please plan carefully when deploying with a custom CA certificate. This certificate
can not be reconfigured once deployed and requires a full re-installation of the
cluster to replace.
====

Administrators can provide custom CA certificates (root CAs or intermediate CAs)
during cluster deployment and decide which CA components to replace (multiple CA certificates) or if to replace all with a single CA certificate.

After you have run `skuba cluster init`, go to the `my-cluster` folder that has been generated,
Create a `pki` folder and put your custom CA certificate into the `pki` folder.

.Extracting Certificate And Key From Combined PEM File
[NOTE]
====
Some PKIs will issue certificates and keys in a combined `.pem` file.
In order to use the contained certificate, you must extract them into separate files using `openssl`.

. Extract the certificate:
+
[source,bash]
----
openssl x509 -in /path/to/file.pem -out /path/to/file.crt
----
. Extract the key:
+
[source,bash]
----
openssl rsa -in /path/to/file.pem -out /path/to/file.key
----
====

* Replacing the {kube} `apiserver` CA certificate:
+
[source,bash]
----
mkdir -p my-cluster/pki
cp <CUSTOM_APISERVER_CA_CERT_PATH> my-cluster/pki/ca.crt
cp <CUSTOM_APISERVER_CA_KEY_PATH> my-cluster/pki/ca.key
chmod 644 my-cluster/pki/ca.crt
chmod 600 my-cluster/pki/ca.key
----

* Replacing the `etcd` CA certificate:
+
[source,bash]
----
mkdir -p my-cluster/pki/etcd
cp <CUSTOM_ETCD_CA_CERT_PATH> my-cluster/pki/etcd/ca.crt
cp <CUSTOM_ETCD_CA_KEY_PATH> my-cluster/pki/etcd/ca.key
chmod 644 my-cluster/pki/etcd/ca.crt
chmod 600 my-cluster/pki/etcd/ca.key
----

* Replacing the `kubelet` CA certificate:
+
[source,bash]
----
mkdir -p my-cluster/pki
cp <CUSTOM_KUBELET_CA_CERT_PATH> my-cluster/pki/kubelet-ca.crt
cp <CUSTOM_KUBELET_CA_KEY_PATH> my-cluster/pki/kubelet-ca.key
chmod 644 my-cluster/pki/kubelet-ca.crt
chmod 600 my-cluster/pki/kubelet-ca.key
----

* Replacing the `front-end proxy` CA certificate:
+
[source,bash]
----
mkdir -p my-cluster/pki
cp <CUSTOM_FRONTPROXY_CA_CERT_PATH> my-cluster/pki/front-proxy-ca.crt
cp <CUSTOM_FRONTPROXY_CA_KEY_PATH> my-cluster/pki/front-proxy-ca.key
chmod 644 my-cluster/pki/front-proxy-ca.crt
chmod 600 my-cluster/pki/front-proxy-ca.key
----

After this process, bootstrap the cluster with `skuba node bootstrap`.

=== Replacing Server Certificates With Trusted CA Certificates

{productname} uses `oidc-dex` and `oidc-gangway` servers to do authentication and authorization.
Administrators might choose to replace these server's certificates by issuing a trusted CA certificate after cluster deployment.
This way, the user does not have to add specific certificates to their trusted keychain.

* With a Trusted CA Key
+
Please refer to <<addon-certificate-rotation>> on how to use cert-manager and reloader to issue `oidc-dex` and `oidc-gangway` certificates signed by trusted CA certificate/key.

* Without a Trusted CA Key
+
[WARNING]
====
Because the custom trusted CA certificate is not in the {kube} cluster, administrators must handle server certificate rotation manually before the certificate expires.
====
+
[WARNING]
====
The `oidc-dex` and `oidc-gangway` server certificate and key is replaced when `skuba addon upgrade apply` contains a dex or gangway addon upgrade.
Make sure to reapply your changes after running `skuba addon upgrade apply`, had you modified the default settings of oidc-dex and oidc-gangway addons.
====

** Replace the `oidc-dex` server certificate:

. Backup the original `oidc-dex` server certificate and key from secret resource.
+
[source,bash]
----
mkdir -p pki.bak
kubectl get secret oidc-dex-cert -n kube-system -o yaml | tee pki.bak/oidc-dex-cert.yaml > /dev/null

cat pki.bak/oidc-dex-cert.yaml | grep tls.crt | awk '{print $2}' | base64 --decode | tee pki.bak/oidc-dex.crt > /dev/null
cat pki.bak/oidc-dex-cert.yaml | grep tls.key | awk '{print $2}' | base64 --decode | tee pki.bak/oidc-dex.key > /dev/null
----

. Get the original SAN IP address(es) and DNS(s), run:
+
[source,bash]
----
openssl x509 -noout -text -in pki.bak/oidc-dex.crt | grep -oP '(?<=IP Address:)[^,]+'
openssl x509 -noout -text -in pki.bak/oidc-dex.crt | grep -oP '(?<=DNS:)[^,]+'
----

. Sign the `oidc-dex` server certificate with the trusted CA certificate.
+
Please refer to <<trusted-server-certificate>> on how to sign the trusted certificate. The `server.conf` for IP.1 is the original SAN IP address if present, DNS.1 is the original SAN DNS if present.
+
Then, import your trusted certificate into the {kube} cluster.
The trusted CA certificates is `<TRUSTED_CA_CERT_PATH>`, trusted server certificate and key are `<SIGNED_OIDC_DEX_SERVER_CERT_PATH>` and `<SIGNED_OIDC_DEX_SERVER_KEY_PATH>`.

. Create a secret manifest file [path]`oidc-dex-cert.yaml` and update the secret data `ca.crt`, `tls.crt`, and `tls.key` with base64; encoded with trusted CA certificate, signed oidc-dex server certificate and key respectively.
+
----
apiVersion: v1
kind: Secret
metadata:
  name: oidc-dex-cert
  namespace: kube-system
  labels:
    caasp.suse.com/skuba-addon: "true"
type: kubernetes.io/tls
data:
  ca.crt: cat <TRUSTED_CA_CERT_PATH> | base64 | awk '{print}' ORS='' && echo
  tls.crt: cat <SIGNED_OIDC_DEX_SERVER_CERT_PATH> | base64 | awk '{print}' ORS='' && echo
  tls.key: cat <SIGNED_OIDC_DEX_SERVER_KEY_PATH> | base64 | awk '{print}' ORS='' && echo
----

. Apply the secret manifest file and restart `oidc-dex` pods.
+
[source,bash]
----
kubectl replace -f oidc-dex-cert.yaml
kubectl rollout restart deployment/oidc-dex -n kube-system
----

** Replace the `oidc-gangway` server certificate:

. Backup the original `oidc-gangway` server certificate and key from secret resource.
+
[source,bash]
----
mkdir -p pki.bak
kubectl get secret oidc-gangway-cert -n kube-system -o yaml | tee pki.bak/oidc-gangway-cert.yaml > /dev/null

cat pki.bak/oidc-gangway-cert.yaml | grep tls.crt | awk '{print $2}' | base64 --decode | tee pki.bak/oidc-gangway.crt > /dev/null
cat pki.bak/oidc-gangway-cert.yaml | grep tls.key | awk '{print $2}' | base64 --decode | tee pki.bak/oidc-gangway.key > /dev/null
----

. Get the original SAN IP address(es) and DNS(s), run:
+
[source,bash]
----
openssl x509 -noout -text -in pki.bak/oidc-gangway.crt | grep -oP '(?<=IP Address:)[^,]+'
openssl x509 -noout -text -in pki.bak/oidc-gangway.crt | grep -oP '(?<=DNS:)[^,]+'
----

. Sign the `oidc-gangway` server certificate with the trusted CA certificate.
+
Please refer to <<trusted-server-certificate>> on how to sign the trusted certificate. The `server.conf` for IP.1 is the original SAN IP address if present, DNS.1 is the original SAN DNS if present.
+
Then, import your trusted certificate into the {kube} cluster.
The trusted CA certificates is `<TRUSTED_CA_CERT_PATH>`, trusted server certificate and key are `<SIGNED_OIDC_GANGWAY_SERVER_CERT_PATH>` and `<SIGNED_OIDC_GANGWAY_SERVER_KEY_PATH>`.

. Create a secret manifest file [path]`oidc-gangway-cert.yaml` and update the secret data `ca.crt`, `tls.crt`, and `tls.key` with base64; encoded with trusted CA certificate, signed `oidc-gangway` server certificate and key respectively.
+
----
apiVersion: v1
kind: Secret
metadata:
  name: oidc-gangway-cert
  namespace: kube-system
  labels:
    caasp.suse.com/skuba-addon: "true"
type: kubernetes.io/tls
data:
  ca.crt: cat <TRUSTED_CA_CERT_PATH> | base64 | awk '{print}' ORS='' && echo
  tls.crt: cat <SIGNED_OIDC_GANGWAY_SERVER_CERT_PATH> | base64 | awk '{print}' ORS='' && echo
  tls.key: cat <SIGNED_OIDC_GANGWAY_SERVER_KEY_PATH> | base64 | awk '{print}' ORS='' && echo
----

. Apply the secret manifest file and restart `oidc-gangway` pods.
+
[source,bash]
----
kubectl replace -f oidc-gangway-cert.yaml
kubectl rollout restart deployment/oidc-gangway -n kube-system
----

== Automatic Certificate Renewal

{productname} renews the control plane certificates and kubeconfigs automatically in two ways:

. *During node upgrade*:
when the node is upgraded, all the kubeadm managed certificates and kubeconfigs, and kubelet client certificates get rotated.

. *Via the `kucero` addon*:
if the administrator is not willing to upgrade the cluster, the `kucero` (KUbernetes control plane CErtificate ROtation) addon rotates all the kubeadm managed certificates and kubeconfigs, and kubelet client and server certificates.
`Kucero` consists of two components:
  .. A kubeadm checker/renewer in the form of a DaemonSet, which is deployed on master nodes. It's job is to periodically check and renew control plane kubeadm managed certificates/kubeconfigs.
  .. A kubelet server CSR signer controller, which signs the kubelet server CSR with a kubelet CA cert/key pair. The signed server certificates are stored in `/var/lib/kubelet/pki` and `/var/lib/kubelet/pki/kubelet-server-current.pem` is a symlink to the last generated server certificate.

[NOTE]
====
During the kubelet client certificate signing flow, kubelet sends the kubelet client CSR into the {kube} cluster, after which the `kube-controller-manager` signs the kubelet client CSR with the Kubernetes CA cert/key pair.

The kubelet client deafult configuration uses a `kubelet-client-current.pem` file in the
`/var/lib/kubelet/pki` folder. This file is a symlink to the latest generated certificate.
====

=== Control Plane Nodes Certificate Rotation

Certificates are rotated in two ways:

. *During node upgrade*:
when doing a control plane update, `skuba node upgrade apply` runs `kubeadm upgrade` commands behind the scenes. `kubeadm upgrade apply` and
`kubeadm upgrade node` renews and uses new `kubeadm` managed certificates on the node, including those stored in kubeconfig files, regardless of the remaining time for which the certificate was still valid.

. *Via the kucero addon:*
.. A kubeadm checker/renewer: kucero periodically checks (default interval is 1 hour) the kubeadm managed certificates/kubeconfigs, and rotates the certificates/kubeconfigs if the residual time is less than the total time (default 720 hours). Administrators can change the default time to renew the certificates/kubeconfigs by adding `--renew-before=<duration>`` (duration format is XhYmZs) to the kucero daemonset _or_ change the default polling period for checking the certificates/kubeconfigs by adding `--polling-period=<duration>` (duration format is XhYmZs).
.. A kubelet server CSR signer controller: kucero signs the kubelet server CSR using the kubelet CA cert/key pair located in control plane node.


=== Worker Node Certificate Rotation

The kubelet client certificate are signed by kube-controller-manager and the kubelet server certificates are signed by the kucero addon.

[[addon-certificate-rotation]]
=== Addon Certificate Rotation

The addon certificates can be automatically rotated by leveraging the functions of the open-source solutions `cert-manager` and `reloader`. `cert-manager` is for automatically rotating certificates stored in Secrets, and `reloader` is for watching and reconciling the updated Secrets to execute a rolling upgrade of the affected Deployments or DaemonSet.

* Prerequisites

. To let `reloader` do an automatic rolling upgrade of the addon Deployments or DaemonSet, we need to label the addons:
+
[source,bash]
----
kubectl annotate --overwrite deployment/oidc-dex -n kube-system secret.reloader.stakater.com/reload=oidc-dex-cert

kubectl annotate --overwrite deployment/oidc-gangway -n kube-system secret.reloader.stakater.com/reload=oidc-gangway-cert

kubectl annotate --overwrite deployment/metrics-server -n kube-system secret.reloader.stakater.com/reload=metrics-server-cert
----

. Upload the Kubernetes CA cert/key pair to Secret in the `kube-system` namespace:
+
[source,bash]
----
kubectl create secret tls kubernetes-ca --cert=pki/ca.crt --key=pki/ca.key -n kube-system
----
+
[NOTE]
====
If you want to use a custom trusted CA certificate/key to sign the certificate, upload to the secret resource.

[source,bash]
----
kubectl create secret tls custom-trusted-ca --cert=<CUSTOM_TRUSTED_CA_CERT> --key=<CUSTOM_TRUSTED_CA_KEY> -n kube-system
----
====

. Install reloader via helm chart:
+
[source,bash]
----
helm install suse/reloader \
    --name ${RELEASE_NAME} \
    --namespace cert-manager
----

. Install cert-manager via helm chart:
+
[source,bash]
----
helm install jetstack/cert-manager \
    --name ${RELEASE_NAME} \
    --namespace cert-manager \
    --set global.leaderElection.namespace=cert-manager \
    --set installCRDs=true
----

* Create a Cert-Manager CA Issuer Resource
+
The cert-manager CA issuer is a {kube} resource that represents a certificate authority (CA), which is able to generate signed certificates by honoring certificate signing requests (CSR). Each cert-manager certificate resource requires one referenced issuer in the ready state to be able to honor CSR requests.
+
[NOTE]
====
An `Issuer` is a namespaced resource, and it can not issue certificates to the certificate resources in other namespaces.

If you want to create a single Issuer that can be consumed in multiple namespaces, you should consider creating a `ClusterIssuer` resource. This is almost identical to the Issuer resource, however, it is cluster-wide so it can be used to issue certificates in all namespaces.
====
+
Create a CA issuer called `kubernetes-ca` that will sign incoming certificate requests based on the CA certificate and private key stored in the secret `kubernetes-ca` used to trust newly signed certificates.
+
[source,bash]
----
cat << EOF > issuer.yaml
apiVersion: cert-manager.io/v1alpha3
kind: Issuer
metadata:
  name: kubernetes-ca // <1>
  namespace: kube-system
spec:
  ca:
    secretName: kubernetes-ca // <2>
EOF

kubectl apply -f issuer.yaml
----
<1> The issuer name.
<2> The secret reference name.
+
[NOTE]
====
If you want to use custom trusted CA certificate/key to sign the certificate, create a custom trusted CA issuer.

[source,bash]
----
cat << EOF > custom-trusted-ca-issuer.yaml
apiVersion: cert-manager.io/v1alpha3
kind: Issuer // <1>
metadata:
  name: custom-trusted-ca
  namespace: kube-system
spec:
  ca:
    secretName: custom-trusted-ca
EOF

kubectl apply -f custom-trusted-ca-issuer.yaml
----
<1> Issuer or ClusterIssuer.
====

* Create a Cert-Manager Certificate Resource
+
The cert-manager has a custom resource, Certificate, which can be used to define a requested x509 certificate which will be renewed and kept up to date by an Issuer or ClusterIssuer resource.
+
** oidc-dex certificate
+
[source,bash]
----
cat << EOF > oidc-dex-certificate.yaml
apiVersion: cert-manager.io/v1alpha3
kind: Certificate
metadata:
  name: oidc-dex-cert
  namespace: kube-system
spec:
  subject:
    organizations:
    - system:masters
  commonName: oidc-dex
  duration: 8760h # 1 year // <1>
  renewBefore: 720h # 1 month // <2>
  # At least one of a DNS Name or IP address is required.
  dnsNames:
  - $(cat admin.conf | grep server | awk '{print $2}' | sed 's/https:\/\///g' | sed 's/:6443//g') // <3>
  ipAddresses:
  - $(cat admin.conf | grep server | awk '{print $2}' | sed 's/https:\/\///g' | sed 's/:6443//g') // <4>
  secretName: oidc-dex-cert
  issuerRef:
    name: kubernetes-ca // <5>
    kind: Issuer // <6>
    group: cert-manager.io
  isCA: false
  usages:
    - digital signature
    - key encipherment
    - server auth
  keySize: 2048
  keyAlgorithm: rsa
  keyEncoding: pkcs1
EOF

kubectl apply -f oidc-dex-certificate.yaml
----
<1> Default length of certificate validity, in the format (XhYmZs).
<2> Certificate renewal time before validity expires, in the format (XhYmZs).
<3> DNSNames is a list of subject alt names to be used on the Certificate.
<4> IPAddresses is a list of IP addresses to be used on the Certificate.
<5> The cert-manager issuer name.
<6> Issuer or ClusterIssuer.
+
This certificate will tell cert-manager to attempt to use the Issuer named kubernetes-ca to obtain a certificate key pair for the domain list in dnsNames and ipAddresses. If successful, the resulting key and certificate will be stored in a secret named oidc-dex-cert with keys of tls.key and tls.crt respectively.
+
The dnsNames and ipAddresses fields specify a list of Subject Alternative Names to be associated with the certificate.
+
The referenced Issuer must exist in the same namespace as the Certificate. A Certificate can alternatively reference a ClusterIssuer which is cluster-wide so it can be referenced from any namespace.
+
[NOTE]
====
If you want to use a custom trusted CA Issuer/ClusterIssuer, change the value of `name` under `issuerRef` to `custom-trusted-ca` and the value of  `kind` under `issuerRef` to `Issuer/ClusterIssuer`.
====

** oidc-gangway certificate
+
[source,bash]
----
cat << EOF > oidc-gangway-certificate.yaml
apiVersion: cert-manager.io/v1alpha3
kind: Certificate
metadata:
  name: oidc-gangway-cert
  namespace: kube-system
spec:
  subject:
    organizations:
    - system:masters
  commonName: oidc-gangway
  duration: 8760h # 1 year // <1>
  renewBefore: 720h # 1 month // <2>
  # At least one of a DNS Name or IP address is required.
  dnsNames:
  - $(cat admin.conf | grep server | awk '{print $2}' | sed 's/https:\/\///g' | sed 's/:6443//g') // <3>
  ipAddresses:
  - $(cat admin.conf | grep server | awk '{print $2}' | sed 's/https:\/\///g' | sed 's/:6443//g') // <4>
  secretName: oidc-gangway-cert
  issuerRef:
    name: kubernetes-ca // <5>
    kind: Issuer // <6>
    group: cert-manager.io
  isCA: false
  usages:
    - digital signature
    - key encipherment
    - server auth
  keySize: 2048
  keyAlgorithm: rsa
  keyEncoding: pkcs1
EOF

kubectl apply -f oidc-gangway-certificate.yaml
----
<1> Default length of certificate validity, in the format (XhYmZs).
<2> Certificate renewal time before validity expires, in the format (XhYmZs).
<3> DNSNames is a list of subject alt names to be used on the Certificate.
<4> IPAddresses is a list of IP addresses to be used on the Certificate.
<5> The cert-manager issuer name.
<6> Issuer or ClusterIssuer.
+
[NOTE]
====
If you want to use a custom trusted CA Issuer/ClusterIssuer, change the value of `name` under `issuerRef` to `custom-trusted-ca` and the value of  `kind` under `issuerRef` to `Issuer/ClusterIssuer`.
====

** metrics-server certificate
+
[source,bash]
----
cat << EOF > metrics-server-certificate.yaml
apiVersion: cert-manager.io/v1alpha3
kind: Certificate
metadata:
  name: metrics-server-cert
  namespace: kube-system
spec:
  subject:
    organizations:
    - system:masters
  commonName: metrics-server.kube-system.svc
  duration: 8760h # 1 year // <1>
  renewBefore: 720h # 1 month // <2>
  # At least one of a DNS Name or IP address is required.
  dnsNames:
  - $(cat admin.conf | grep server | awk '{print $2}' | sed 's/https:\/\///g' | sed 's/:6443//g') // <3>
  ipAddresses:
  - $(cat admin.conf | grep server | awk '{print $2}' | sed 's/https:\/\///g' | sed 's/:6443//g') // <4>
  secretName: metrics-server-cert
  issuerRef:
    name: kubernetes-ca // <5>
    kind: Issuer // <6>
    group: cert-manager.io
  isCA: false
  usages:
    - digital signature
    - key encipherment
    - server auth
  keySize: 2048
  keyAlgorithm: rsa
  keyEncoding: pkcs1
EOF

kubectl apply -f metrics-server-certificate.yaml
----
<1> Default length of certificate validity, in the format (XhYmZs).
<2> Certificate renewal time before validity expires, in the format (XhYmZs).
<3> DNSNames is a list of subject alt names to be used on the Certificate.
<4> IPAddresses is a list of IP addresses to be used on the Certificate.
<5> The cert-manager issuer name.
<6> Issuer or ClusterIssuer.

== Manual Certificate Renewal

[IMPORTANT]
====
If you are running multiple master nodes, you need to run the followings
commands sequentially on all master nodes.
====

=== Renewing Certificates Managed by `kubeadm`

. To SSH into the master node, renew all `kubeadm` certificates and reboot,
run the following:
+
[source,bash]
----
ssh <USERNAME>@<MASTER_NODE_IP_ADDRESS/FQDN>
sudo cp -r /etc/kubernetes/pki /etc/kubernetes/pki.bak
sudo kubeadm alpha certs renew all
sudo systemctl restart kubelet
----
+
. Copy the renewed `admin.conf` from one of the master nodes to your local environment:
+
[source,bash]
----
ssh <USERNAME>@<MASTER_NODE_IP_ADDRESS/FQDN>
sudo cat /etc/kubernetes/admin.conf
----

=== Renewing Certificates Created by `skuba`:

In the admin node, regenerate the certificates:

* Replace the `oidc-dex` server certificate:
+
. Backup the original `oidc-dex` server certificate and key from secret resource.
+
[source,bash]
----
mkdir -p my-cluster/pki.bak
kubectl get secret oidc-dex-cert -n kube-system -o yaml | tee my-cluster/pki.bak/oidc-dex-cert.yaml > /dev/null

cat my-cluster/pki.bak/oidc-dex-cert.yaml | grep tls.crt | awk '{print $2}' | base64 --decode | tee my-cluster/pki.bak/oidc-dex.crt > /dev/null
cat my-cluster/pki.bak/oidc-dex-cert.yaml | grep tls.key | awk '{print $2}' | base64 --decode | tee my-cluster/pki.bak/oidc-dex.key > /dev/null
----

. Get the original SAN IP address(es) and DNS(s), run:
+
[source,bash]
----
openssl x509 -noout -text -in /etc/kubernetes/pki.bak/oidc-dex.crt | grep -oP '(?<=IP Address:)[^,]+'
openssl x509 -noout -text -in /etc/kubernetes/pki.bak/oidc-dex.crt | grep -oP '(?<=DNS:)[^,]+'
----

. Sign the `oidc-dex` server certificate with the default kubernetes CA certificate _or_ trusted CA certificate.
.. Default kubernetes CA certificate
+
Please refer to <<self-signed-server-certificate>> on how to sign the self signed server certificate. The default kubernetes CA certificate and key are located at `/etc/kubernetes/pki/ca.crt` and `/etc/kubernetes/pki/ca.key`. The `server.conf` for IP.1 is the original SAN IP address if present, DNS.1 is the original SAN DNS if present.
+
.. Trusted CA certificate
+
Please refer to <<trusted-server-certificate>> on how to sign the trusted server certificate. The `server.conf` for IP.1 is the original SAN IP address if present, DNS.1 is the original SAN DNS if present.

. Import your certificate into the {kube} cluster.
The CA certificate is `<CA_CERT_PATH>`, server certificate and key are `<SIGNED_OIDC_DEX_SERVER_CERT_PATH>` and `<SIGNED_OIDC_DEX_SERVER_KEY_PATH>`.

. Create a secret manifest file [path]`oidc-dex-cert.yaml` and update the secret data `ca.crt`, `tls.crt`, and `tls.key` with base64; encoded with CA certificate, signed `oidc-dex` server certificate and key respectively.
+
----
apiVersion: v1
kind: Secret
metadata:
  name: oidc-dex-cert
  namespace: kube-system
  labels:
    caasp.suse.com/skuba-addon: "true"
type: kubernetes.io/tls
data:
  ca.crt: cat <CA_CERT_PATH> | base64 | awk '{print}' ORS='' && echo
  tls.crt: cat <SIGNED_OIDC_DEX_SERVER_CERT_PATH> | base64 | awk '{print}' ORS='' && echo
  tls.key: cat <SIGNED_OIDC_DEX_SERVER_KEY_PATH> | base64 | awk '{print}' ORS='' && echo
----

. Apply the secret manifest file and restart `oidc-dex` pods.
+
[source,bash]
----
kubectl replace -f oidc-dex-cert.yaml
kubectl rollout restart deployment/oidc-dex -n kube-system
----

* Replace the `oidc-gangway` server certificate:
+
. Backup the original `oidc-gangway` server certificate and key from secret resource.
+
[source,bash]
----
mkdir -p my-cluster/pki.bak
kubectl get secret oidc-gangway-cert -n kube-system -o yaml | tee my-cluster/pki.bak/oidc-gangway-cert.yaml > /dev/null

cat my-cluster/pki.bak/oidc-gangway-cert.yaml | grep tls.crt | awk '{print $2}' | base64 --decode | tee my-cluster/pki.bak/oidc-gangway.crt > /dev/null
cat my-cluster/pki.bak/oidc-gangway-cert.yaml | grep tls.key | awk '{print $2}' | base64 --decode | tee my-cluster/pki.bak/oidc-dgangwayex.key > /dev/null
----

. Get the original SAN IP address(es) and DNS(s), run:
+
[source,bash]
----
openssl x509 -noout -text -in /etc/kubernetes/pki.bak/oidc-gangway.crt | grep -oP '(?<=IP Address:)[^,]+'
openssl x509 -noout -text -in /etc/kubernetes/pki.bak/oidc-gangway.crt | grep -oP '(?<=DNS:)[^,]+'
----

. Sign the `oidc-gangway` server certificate with the default kubernetes CA certificate _or_ trusted CA certificate.
.. Default kubernetes CA certificate
+
Please refer to <<self-signed-server-certificate>> on how to sign the self signed server certificate. The default kubernetes CA certificate and key are located at `/etc/kubernetes/pki/ca.crt` and `/etc/kubernetes/pki/ca.key`. The `server.conf` for IP.1 is the original SAN IP address if present, DNS.1 is the original SAN DNS if present.
+
.. Trusted CA certificate
+
Please refer to <<trusted-server-certificate>> on how to sign the trusted server certificate. The `server.conf` for IP.1 is the original SAN IP address if present, DNS.1 is the original SAN DNS if present.

. Import your certificate into the {kube} cluster.
The CA certificates is `<CA_CERT_PATH>`, server certificate and key are `<SIGNED_OIDC_GANGWAY_SERVER_CERT_PATH>` and `<SIGNED_OIDC_GANGWAY_SERVER_KEY_PATH>`.

. Create a secret manifest file [path]`oidc-gangway-cert.yaml` and update the secret data `ca.crt`, `tls.crt`, and `tls.key` with base64; encoded with CA certificate, signed `oidc-gangway` server certificate and key respectively.
+
----
apiVersion: v1
kind: Secret
metadata:
  name: oidc-gangway-cert
  namespace: kube-system
  labels:
    caasp.suse.com/skuba-addon: "true"
type: kubernetes.io/tls
data:
  ca.crt: cat <CA_CERT_PATH> | base64 | awk '{print}' ORS='' && echo
  tls.crt: cat <SIGNED_OIDC_GANGWAY_SERVER_CERT_PATH> | base64 | awk '{print}' ORS='' && echo
  tls.key: cat <SIGNED_OIDC_GANGWAY_SERVER_KEY_PATH> | base64 | awk '{print}' ORS='' && echo
----

. Apply the secret manifest file and restart `oidc-gangway` pods.
+
[source,bash]
----
kubectl replace -f oidc-gangway-cert.yaml
kubectl rollout restart deployment/oidc-gangway -n kube-system
----

* Replace the `kubelet` server certificate:
+
[IMPORTANT]
====
You need to generate `kubelet` server certificate for all the nodes on one of control plane nodes.
The `kubelet` CA certificate key only exists on the control plane nodes.
Therefore, after generating re-signed `kubelet` server certificate/key for worker nodes, you have to copy each `kubelet` server certificate/key from the control plane node to the corresponding worker node.
====
. Backup the original `kubelet` certificates and keys.
+
[source,bash]
----
sudo cp -r /var/lib/kubelet/pki /var/lib/kubelet/pki.bak
----
+
. Sign each node `kubelet` server certificate with the CA certificate/key `/var/lib/kubelet/pki/kubelet-ca.crt` and `/var/lib/kubelet/pki/kubelet-ca.key`, make sure that the signed server certificate SAN is the same as the origin.
To get the original SAN IP address(es) and DNS(s), run:
+
[source,bash]
----
openssl x509 -noout -text -in /var/lib/kubelet/pki.bak/kubelet.crt | grep -oP '(?<=IP Address:)[^,]+'
openssl x509 -noout -text -in /var/lib/kubelet/pki.bak/kubelet.crt | grep -oP '(?<=DNS:)[^,]+'
----
+
. Finally, update the `kubelet` server certificate and key file `/var/lib/kubelet/kubelet.crt` and `/var/lib/kubelet/kubelet.key` respectively, and restart `kubelet` service.
+
[source,bash]
----
sudo cp <CUSTOM_KUBELET_SERVER_CERT_PATH> /var/lib/kubelet/pki/kubelet.crt
sudo cp <CUSTOM_KUBELET_SERVER_KEY_PATH> /var/lib/kubelet/pki/kubelet.key
chmod 644 /var/lib/kubelet/pki/kubelet.crt
chmod 600 /var/lib/kubelet/pki/kubelet.key

sudo systemctl restart kubelet
----

== How To Generate Certificates

[#trusted-signed-certificate]
=== Trusted 3rd-Party Signed Certificate

[#trusted-server-certificate]
==== Trusted Server Certificate

. Generate a private key by following the steps below from a terminal window:
+
[source,bash]
----
openssl genrsa -aes256 -out server.key 2048
----
+
Type the pass phrase to protect the key and press [Enter]
+
Re-enter the pass phrase.
. Create a file _server.conf_ with the appropriate values
+
----
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = CZ // <1>
ST = CZ // <2>
L = Prague // <3>
O = example // <4>
OU = com // <5>
CN = server.example.com // <6>
emailAddress = admin@example.com // <7>

[v3_req]
basicConstraints = critical,CA:FALSE
keyUsage = critical,digitalSignature,keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
IP.1 = <SERVER-IP-ADDRESS> // <8>
DNS.1 = <SERVER-FQDN> // <9>
----
<1> Country Name (2 letter code).
<2> State or Province Name (full name).
<3> Locality Name (eg, city).
<4> Organization Name (eg, company).
<5> Organizational Unit Name (eg, section).
<6> Common Name (e.g. server FQDN or YOUR name)
<7> Email Address
<8> Server IP address if present. Add more IP.X below if the server has more than one IP address.
Remove IP.1 if the server uses FQDN.
<9> Server FQDN if present. Add more DNS.X below if the server has more than one domain name.
Remove DNS.1 if the server uses an IP address.

. Generate a certificate signing request (CSR)
+
[source,bash]
----
openssl req -new -key server.key -config server.conf -out server.csr
----
Enter the pass phrase of the private key created in Step 1.
+
Check the certificate signing request (CSR)
+
[source,bash]
----
openssl req -text -noout -verify -in server.csr
----

. Sign the certificate
+
Send the certificate signing request (CSR) to the 3rd party for signing.
You should receive the following files in return:
+
.. Server certificate (public key)
.. Intermediate CA and/or bundles that chain to the Trusted Root CA

[#trusted-client-certificate]
==== Trusted Client Certificate

. Generate a private key by following the steps below from a terminal window:
+
[source,bash]
----
openssl genrsa -aes256 -out client.key 2048
----
+
Type the pass phrase to protect the key and press [Enter]
+
Re-enter the pass phrase.
. Create a file _client.conf_ with the appropriate values
+
----
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = CZ // <1>
ST = CZ // <2>
L = Prague // <3>
O = example // <4>
OU = com // <5>
CN = client.example.com // <6>
emailAddress = admin@example.com // <7>

[v3_req]
basicConstraints = critical,CA:FALSE
keyUsage = critical,digitalSignature,keyEncipherment
extendedKeyUsage = clientAuth
----
<1> Country Name (2 letter code).
<2> State or Province Name (full name).
<3> Locality Name (eg, city).
<4> Organization Name (eg, company).
<5> Organizational Unit Name (eg, section).
<6> Common Name (e.g. client FQDN or YOUR name)
<7> Email Address

. Generate a certificate signing request (CSR)
+
[source,bash]
----
openssl req -new -key client.key -config client.conf -out client.csr
----
Enter the pass phrase of the private key created in Step 1.
+
Check the certificate signing request (CSR)
+
[source,bash]
----
openssl req -text -noout -verify -in client.csr
----

. Sign the certificate
+
Send the certificate signing request (CSR) to the 3rd party for signing.
You should receive the following files in return:
+
.. Client certificate (public key)
.. Intermediate CA and/or bundles that chain to the Trusted Root CA

[#self-signed-certificate]
=== Self-signed Server Certificate

[NOTE]
====
In the case that you decide to use self-signed certificates, make sure that the Certificate Authority
used for signing is configured securely as a trusted Certificate Authority on the clients.
====

In some cases you want to create self-signed certificates for testing.
If you are using proper trusted 3rd-party CA signed certificates, skip the following steps and refer to <<trusted-server-certificate>>.

[#self-signed-ca-certificate]
==== Self-signed CA Certificate

. Create a file _ca.conf_ with the appropriate values
+
----
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_ca
prompt = no

[req_distinguished_name]
C = CZ // <1>
ST = CZ // <2>
L = Prague // <3>
O = example // <4>
OU = com // <5>
CN = Root CA // <6>
emailAddress = admin@example.com // <7>

[v3_ca]
basicConstraints = critical,CA:TRUE
keyUsage = critical,digitalSignature,keyEncipherment,keyCertSign
----
<1> Country Name (2 letter code).
<2> State or Province Name (full name).
<3> Locality Name (eg, city).
<4> Organization Name (eg, company).
<5> Organizational Unit Name (eg, section).
<6> Common Name (e.g. server FQDN or YOUR name)
<7> Email Address

. Sign the CA certificate
+
[source,bash]
----
openssl genrsa -out ca.key 2048
openssl req -key ca.key -new -x509 -days 3650 -sha256 -config ca.conf -out ca.crt
----

[#self-signed-server-certificate]
==== Self-signed Server Certificate

. Create a file _server.conf_ with the appropriate values
+
----
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = CZ // <1>
ST = CZ // <2>
L = Prague // <3>
O = example // <4>
OU = com // <5>
CN = example.com // <6>
emailAddress = admin@example.com // <7>

[v3_req]
basicConstraints = critical,CA:FALSE
keyUsage = critical,digitalSignature,keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
IP.1 = <SERVER-IP-ADDRESS> // <8>
DNS.1 = <SERVER-FQDN> // <9>
----
<1> Country Name (2 letter code).
<2> State or Province Name (full name).
<3> Locality Name (eg, city).
<4> Organization Name (eg, company).
<5> Organizational Unit Name (eg, section).
<6> Common Name (e.g. server FQDN or YOUR name)
<7> Email Address
<8> Server IP address if present. Add more IP.X below if the server has more than one IP address.
Remove IP.1 if the server uses FQDN.
<9> Server FQDN if present. Add more DNS.X below if the server has more than one domain name.
Remove DNS.1 if the server uses an IP address.

. Generate the certificate
+
[source,bash]
----
openssl genrsa -out server.key 2048
openssl req -key server.key -new -sha256 -out server.csr -config server.conf
openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt -days 365 -extensions v3_req -extfile server.conf
----
+
Check the signed certificate
+
[source,bash]
----
openssl x509 -text -noout -in server.crt
----

[#self-signed-client-certificate]
==== Self-signed Client Certificate

. Create a file _client.conf_ with the appropriate values
+
----
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = CZ // <1>
ST = CZ // <2>
L = Prague // <3>
O = example // <4>
OU = com // <5>
CN = client.example.com // <6>
emailAddress = admin@example.com // <7>

[v3_req]
basicConstraints = critical,CA:FALSE
keyUsage = critical,digitalSignature,keyEncipherment
extendedKeyUsage = clientAuth
----
<1> Country Name (2 letter code).
<2> State or Province Name (full name).
<3> Locality Name (eg, city).
<4> Organization Name (eg, company).
<5> Organizational Unit Name (eg, section).
<6> Common Name (e.g. server FQDN or YOUR name)
<7> Email Address

. Generate the certificate
+
[source,bash]
----
openssl genrsa -out client.key 2048
openssl req -key client.key -new -sha256 -out client.csr -config client.conf
openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt -days 365 -extensions v3_req -extfile client.conf
----
+
Check the signed certificate
+
[source,bash]
----
openssl x509 -text -noout -in client.crt
----
